import tensorflow as tf
import numpy as np
from utils import _run
import matplotlib as mpl
mpl.use('agg')
import matplotlib.pyplot as plt
plt.rcParams['image.cmap']='gray'
plt.ion()


"""
counts number of data examples per class in a tfrecord file
input
tfrecords_filename: path to tfrecord file containing data as generated by build_image_data._process_dataset
output
count_array : array of length nClass where nClass is the number of classes and count_array[i] has the number of
              training/test examples for class i
"""
def count_nClass(tfrecords_filename = "data/train-00000-of-00001"):
    count_array = np.array([0])
    record_iterator = tf.python_io.tf_record_iterator(path=tfrecords_filename)
    for string_record in record_iterator:
        example = tf.train.Example()
        example.ParseFromString(string_record)
        lab = int(example.features.feature['image/class/label'].int64_list.value[0])
        if lab>count_array.shape[0]:
            count_array_temp       = np.zeros(lab)
            ind = count_array_temp[lab - 1]
            ind += 1
            count_array_temp[lab - 1] = int(ind)
            count_array_temp[lab-1]= count_array_temp[lab-1]+1
            for i in range(count_array.shape[0]):
                count_array_temp[i] = count_array[i]
            count_array = count_array_temp.copy()
        else:
            ind = count_array[lab - 1]
            ind += 1
            count_array[lab - 1] = int(ind)
    return count_array.astype(np.int32)



"""
counts number of data examples per class in a tfrecord file
input
tfrecords_filename: path to tfrecord file containing data as generated by build_image_data._process_dataset
output
k : int number of examples in data set across all classes
"""
def count_data(tfrecords_filename = "data/train-00000-of-00001"):
 record_iterator = tf.python_io.tf_record_iterator(path=tfrecords_filename)
 k = 0
 for string_record in record_iterator:
    k = k+1
 return k

#displays the images in the tfrecords
def check_ims(tfrecords_filename = "data/train-00000-of-00001",nIm=1):
 record_iterator = tf.python_io.tf_record_iterator(path=tfrecords_filename)

 shitfiles = []
 k = 0
 for string_record in record_iterator:
    # Parse the next example
    example = tf.train.Example()
    example.ParseFromString(string_record)

    # Get the features you stored (change to match your tfrecord writing code)
    height = int(example.features.feature['image/height']
                                 .int64_list
                                 .value[0])

    width = int(example.features.feature['image/width']
                                .int64_list
                                .value[0])

    img_string = (example.features.feature['image/encoded']
                                  .bytes_list
                                  .value[0])
    #text = example.features.feature['image/class/text'].bytes_list.value[0]
    #k = k+1
    name = example.features.feature['image/filename'].bytes_list.value[0].decode('utf-8')
    # Convert to a numpy array (change dtype to the datatype you stored)
    #img_1d = np.fromstring(img_string, dtype=np.uint8)
    #tfimg_1d = tf.decode_raw(example.features.feature['image/encoded'],tf.uint8)
    #tfimg_1d = tf.decode_raw(img_string,tf.uint8)
    try:
       lab = example.features.feature['image/class/label'].int64_list.value[0]
    except IndexError:
       lab = 'no Lab'
       shitfiles = shitfiles + [name]
    k = k + 1
    if k > nIm: break

    if k%500==0: 
     image = _run(tf.image.decode_jpeg(img_string, channels=1))
     print(image.shape)
     print(str(lab)+' '+name )
     plt.imshow(image[:,:,0])
     plt.title('lab= '+str(lab)+' example '+str(k))
     plt.pause(0.1)
     #Print the image shape; does it match your expectations?

    
    #if k>nIm: break

 return name,_run(tf.image.decode_jpeg(img_string, channels=1))

#returns the size of the images in the tfrecords
def check_size(tfrecords_filename = "data/train-00000-of-00001",nIm=1):
 record_iterator = tf.python_io.tf_record_iterator(path=tfrecords_filename)

 shitfiles = []
 k = 0
 for string_record in record_iterator:
    # Parse the next example
    example = tf.train.Example()
    example.ParseFromString(string_record)

    # Get the features you stored (change to match your tfrecord writing code)
    height = int(example.features.feature['image/height']
                                 .int64_list
                                 .value[0])

    width = int(example.features.feature['image/width']
                                .int64_list
                                .value[0])

    img_string = (example.features.feature['image/encoded']
                                  .bytes_list
                                  .value[0])

    #text = example.features.feature['image/class/text'].bytes_list.value[0]
    #k = k+1
    name = example.features.feature['image/filename'].bytes_list.value[0].decode('utf-8')
    # Convert to a numpy array (change dtype to the datatype you stored)
    #img_1d = np.fromstring(img_string, dtype=np.uint8)
    #tfimg_1d = tf.decode_raw(example.features.feature['image/encoded'],tf.uint8)
    #tfimg_1d = tf.decode_raw(img_string,tf.uint8)
    try:
       lab = example.features.feature['image/class/label'].int64_list.value[0]
    except IndexError:
       lab = 'no Lab'
       shitfiles = shitfiles + [name]
    #if k%500==0: 
    image = _run(tf.image.decode_jpeg(img_string, channels=1))
    #print(image.shape)
    # print(str(lab)+' '+name )
    # plt.imshow(image[:,:,0])
    # plt.title('lab= '+str(lab)+' example '+str(k))
    # plt.pause(0.1)
     #Print the image shape; does it match your expectations?
    k = k+1
    
    
    if k>nIm: break

 return image.shape






def getImage(filename,PRE_RESIZE, height, width,nClass):
    shape = check_size()
    DIMX_IM = shape[0]
    DIMY_IM = shape[1]
    # convert filenames to a queue for an input pipeline.
    filenameQ = tf.train.string_input_producer([filename],num_epochs=None)
 
    # object to read records
    recordReader = tf.TFRecordReader()

    # read the full set of features for a single example 
    key, fullExample = recordReader.read(filenameQ)

    # parse the full example into its' component features.
    features = tf.parse_single_example(
        fullExample,
        features={
            'image/height': tf.FixedLenFeature([], tf.int64),
            'image/width': tf.FixedLenFeature([], tf.int64),
            'image/colorspace': tf.FixedLenFeature([], dtype=tf.string,default_value=''),
            'image/channels':  tf.FixedLenFeature([], tf.int64),            
            'image/class/label': tf.FixedLenFeature([],tf.int64),
            'image/class/text': tf.FixedLenFeature([], dtype=tf.string,default_value=''),
            'image/format': tf.FixedLenFeature([], dtype=tf.string,default_value=''),
            'image/filename': tf.FixedLenFeature([], dtype=tf.string,default_value=''),
            'image/encoded': tf.FixedLenFeature([], dtype=tf.string, default_value='')
            #'image/encoded': tf.VarLenFeature([], dtype=tf.string)
        })


    # now we are going to manipulate the label and image features

    label = features['image/class/label']
    image_buffer = features['image/encoded']

    # Decode the jpeg
    with tf.name_scope('decode_jpeg',[image_buffer], None):
        # decode
        image = tf.image.decode_jpeg(image_buffer, channels=1)
    
        # and convert to single precision data type
        image = tf.image.convert_image_dtype(image, dtype=tf.float32)#.set_shape([33,33,1])
        image.set_shape([DIMX_IM,DIMY_IM,1])


    # cast image into a single array, where each element corresponds to the greyscale
    # value of a single pixel. 
    # the "1-.." part inverts the image, so that the background is black.
    if PRE_RESIZE:
      image = tf.image.resize_images(image,[height,width],method=tf.image.ResizeMethod.BICUBIC)
      image = tf.reshape(1-tf.image.rgb_to_grayscale(image),[height*width])
    else:
      image = tf.reshape(1-tf.image.rgb_to_grayscale(image),[DIMX_IM*DIMY_IM])
    # re-define label as a "one-hot" vector
    # it will be [0,1] or [1,0] here. 
    # This approach can easily be extended to more classes.
    label=tf.stack(tf.one_hot(label-1, nClass))
    #image.set_shape([height*width,1])
    #label = tf.cast(features['image/class/label'], tf.int32)
    return label, image#, features['image/filename']


if __name__=="__main__":
   #k = check_ims(nIm = 100)
   im = check_size()
